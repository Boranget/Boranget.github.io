---
title: 深入理解计Java虚拟机
date: 2023-06-28 16:50:30
tags:
  - jvm
categories:
  - 笔记
---

# 参考资料

《深入理解Java虚拟机：第3版》

# 概述

Java，91年诞生，95年发布

09年sun被oracle收购

# 自动内存管理

## 运行时数据区

![image-20230628151146012](深入理解计Java虚拟机/image-20230628151146012.png)

其中，方法区和堆是所有线程共享的数据区，虚拟机栈、本地方法栈、程序计数器为每份线程独有的。

### 程序计数器

当前线程所执行的字节码的行号指针，由于线程切换后需要恢复执行环境，故每条线程都需要一个独立的程序计数器来保存执行位置，这样才能保证各条线程之间互不影响。

如果当前线程执行方法为本地（native）方法，则当前线程该计数器值为空

### 虚拟机栈

Java虚拟机栈也是线程私有，描述Java方法执行的线程内存模型：每个方法执行时，Java虚拟机都会创建一个栈帧，该栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从被调用直至执行完毕的过程，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表中存储的编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型。在局部变量表中这些值会占用不同大小的变量槽，其中64为的long和double会占用两个变量槽，其余类型只占用一个。且据此，局部变量表所需的内存空间在编译期间便是完全确定的，在方法的运行期间不会改变局部变量表的大小。因为在方法运行期间有的变量生命周期会结束，变量槽空出来后可以让别的变量复用。

当当前线程请求的栈深度大于虚拟机允许的深度，会报出StackOverflowError异常，如无休止的方法递归调用。若当前虚拟机可以动态扩展（Hotspot不可以），当扩展无法申请到足够的大小时会报OutOfMemoryError异常。

栈溢出可以查看是否栈帧过大，比如局部变量表中变量过多。或者栈帧过多，比如递归调用。

有一种情况是，若方法栈分配的内存过大，会导致其余内存空间过少，也会导致内存溢出。

### 本地方法栈

与虚拟机栈类似，区别为本地方法站是执行Native方法时使用，而虚拟机栈是执行Java方法所用的栈。

在Hotspot虚拟机中，本地方法栈和虚拟机栈是合并在一起的。

### 堆

所有线程共享的一块区域，在虚拟机启动时创建，用于存放对象实例。存在垃圾回收的机制，且由于垃圾回收有着分代的设计。可通过-Xmx和-Xms设置最大和最小内存，当堆大小不满足对象分配所需空间时会抛出OutOfMemoryError

### 方法区

同样是所有线程共享的区域，用于已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后 代码缓存等区域。

早期Hotspot的永久代是相对于堆中的新生代老年代说的，目的是为了使用堆的垃圾回收机制来管理方法区，现在采取的JRockit的实现方式：使用本地内存实现的元空间。

当方法区内存大小无法满足内存分配时，抛出OutOfMemoryError

若有动态生成类的场景，不断生成新的类，填充到方法区中，导致内存溢出。比如大量的或动态生成JSP文件（JSP会编译为class文件）

#### 运行时常量池

运行时常量池是方法区的一部分。在class文件中的常量池表在类加载后会存放到方法区的运行时常量池中。

### 直接内存

不算虚拟机运行时数据区的一部分，但Java可以分配该区域，且当物理机剩余内存不足时会出现OutOfMemoryError

## Hotspot

### 对象创建

1. 类加载

   当jvm遇到new指令，会首先检查质量参数能否定位到常量池中的类符号引用，接着检查这个类是否已被加载、解析和初始化，若没有，则需要先执行类加载过程。

2. 内存分配

   接着执行内存分配的操作，一个对象所需的内存大小在类加载完成后便可确定，jvm需要从堆中划分出一块存放该对象的空间。

	- 指针碰撞

      堆中维护一个指针，指针前为已分配内存，指针后为空闲内存，每次分配内存从指针开始，分配空间后指针后移。

	- 空闲列表
	
	     jvm维护一个列表，记录哪些内存块是空闲可用的。分配的时候找一块大小合适的内存分配。
	
	不同的垃圾收集器会导致不同的内存状态，从而采取不同的内存分配方式。
	
	存在多个线程分配对象内存时的线程安全问题，一种解决方法为将分配内存的操作加同步处理，另一种解决方式是使用TLAB（Thread Local Allocation Buffer 本地线程分配缓冲）。

3. 初始化

   初始化对象的实例，不保证兑现的实例字段不赋初始值便可使用

4. 其余工作

5. 执行构造方法

   先执行代码块，再执行构造方法，如果有多个代码块，则按声明的顺序执行。实际上，代码块和构造方法都会整合到\<init\>方法中，而静态代码块会被整合到\<cinit\>中。

### 对象的内存布局

内存中的一个对象可以划分为三个部分：对象头、实例数据、对齐填充

- 对象头

  对象头包含两类信息，一类是对象自身的运行数据，如hash值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另一类，存储了类型指针（对象指向它的类型元数据的指针），jvm通过则个指针来确定该对象是哪个类的实例。如果该对象是一个数组，则对象头中还有一个记录数组长度的数据。

- 实例数据

  程序代码中定义的各种类型的字段内容，包括继承父类的。

  默认情况下，相同宽度的字段会被分配在一起（longs/doubles、ints、shourts/chars、bytes/booleans、oops）。且父类中定义的变量会出现在子类之前。如果打开虚拟机参数 +XX: CompactFields，子类中较窄的变量也允许插入父类变量的空隙。

- 对齐填充

  Hotspot要求对象起始地址必须是8字节的整数倍，故对象大小必须填充至8字节的整数倍。

### 访问对象

主要有两种访问方式

- 句柄

  堆中维护一句柄池，每个句柄中要分别指向堆中对象的地址和方法区中对象的类型的地址，变量表中指向句柄

- 直接指针

  变量表中指向堆中对象地址，对象中维护一个指针指向方法区中类型

![image-20230629140626162](深入理解计Java虚拟机/image-20230629140626162.png)

使用句柄的优点是在对象位置移动后只需修改句柄，无需修改变量表中reference的引用，缺点是增加了一次寻址。使用直接指针的方式好处在于快。

Hotspot主要使用直接指针法

